# JVMTI Talk

* Explain difference of JVMTI & JNI

## modules

1-simple: Just a simple example to show that jvmti works on bytecode, not sourcecode

2-npe: JVMTI has enabled devs to improved debugging in the past (pre JDK13)

3-oom: JVMTI can help end the program when something goes wrong

4-stacktraces: JVMTI can help to improve insights of exceptions

## open ideas
Wasn't able to implement faketime and heap walker of https://github.com/odnoklassniki/jvmti-tools

Secrets auslesen
variablen ver√§ndern
breakpoint
track threads
iterate through heap
watch fields
tag objects
understand raw monitor

https://github.com/AndroidAdvanceWithGeektime/JVMTI_Sample | quite complex

https://github.com/HeapStats/heapstats | quite complex

https://github.com/headius/hprof2 | probably better to simply check out

https://github.com/liuzhengyang/jvmti_examples/blob/master/jvmti_example.cpp

https://github.com/kylixs/flare-profiler/tree/master/flare-agent/src

https://github.com/xingfengwxx/MemoryMonitor/blob/master/app/src/main/cpp/native-lib.cpp

https://github.com/karlbennett/count-agent

https://github.com/ali-ghanbari/timer/blob/master/src/main/c/timer.c

https://github.com/Devexperts/aprof

https://github.com/jon-bell/bytecode-examples

todo google search

bookmarks

access values with JNI
